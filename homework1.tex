\documentclass[11pt,fleqn]{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[margin=0.75in]{geometry}
\usepackage[parfill]{parskip}
\usepackage{fancyhdr}
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{amsthm}
\usepackage{algpseudocode}
\usepackage{enumitem}
\usepackage{lastpage}
\usepackage{datetime}
\usepackage{bookmark}
\usepackage{hyperref}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}

\newcommand{\doubleR}{\mathbb{R}}
\newcommand{\doubleC}{\mathbb{C}}
\newcommand{\doubleZ}{\mathbb{Z}}
\newcommand{\doubleQ}{\mathbb{Q}}
\newcommand{\doubleN}{\mathbb{N}}
\newcommand{\RR}{\mathbb{R}}
\newcommand{\CC}{\mathbb{C}}
\newcommand{\ZZ}{\mathbb{Z}}
\newcommand{\QQ}{\mathbb{Q}}
\newcommand{\NN}{\mathbb{N}}
\newcommand{\bigO}{\ensuremath{\mathcal{O}}}

% induction
\newcommand{\Base}{\textbf{Base Step}: }
\newcommand{\IH}{\textbf{Induction Hypothesis}: }
\newcommand{\IS}{\textbf{Induction Step}: }

% theorem and proofs
\newtheorem*{theorem}{Theorem}
% \newtheorem*{statement}{Statement}
\theoremstyle{definition}
\newtheorem*{definition}{Definition}
\theoremstyle{remark}
\newtheorem*{remark}{Remark}

\fancyhf{} % sets both header and footer to nothing
\renewcommand{\headrulewidth}{0pt}
\fancyfoot[C]{Page \thepage}
\pagenumbering{arabic}

\begin{document}

\begin{titlepage}
\title{ECE345 HW1}
\author{ Homework Group \#85 \\
Yanni Alan Alevras | yanni.alevras@mail.utoronto.ca | 1009330706\\
Evan Banerjee | evan.banerjee@mail.utoronto.ca | 1009682309\\
Gautam | gautam.makheja@mail.utoronto.ca | 1008788974}
\date{
Total Pages: \pageref{LastPage}\\[2ex]
\today}
\maketitle

\setcounter{page}{0}
\thispagestyle{empty}
\end{titlepage}
\pagebreak \newpage

\clearpage
\newpage
\pagestyle{fancy}

\section{Question 1 Examples of this is a second test}
\begin{enumerate}
    \item[a.]
    \begin{theorem}
        \normalfont Give a combinatorial argument to prove that 
        \[
        \sum_{k=0}^{n} \binom{n}{k} 2^k = 3^n
        \]
    \end{theorem}
    \begin{proof} Proof by combinatorial Argument \\\\
        imagine you have a bucket with three balls in it, where each ball
        is either red, green, or blue.\\

        let's say each time you pick one of the balls out of the bucket,
        you make a dash on a piece of paper in\\
        whatever color the ball is, and then put the ball back. Assume that
        you write the dashes in order so that after repeating this process
        n times, you end up with a sequence of n dashes in order, where 
        each dash is either red, green, or blue.\\

        since each dash was one of three possible choices, there are 
        ${3}^{n}$ possible sequences of colored dashes 
        that you can draw with this process.\\\\

        Each colored dash has 2 properties, its color, and its index in
        the sequence.\\
        For example, if n = 5, one possible order could be RGGRB.
        in this case, you could represent this unique order as\\\\
        (G, 3), (R, 1), (G, 2), (R, 4), (B, 5)\\\\ 
        where, in each tuple, the letter is the color and
        the number is the index of that color in the sequence.\\

        Clearly the index of each colored dash is going to be a 
        positive integer between 1 and n\\

        Because each unique sequence of n colored dashes can be represented
        by a unique, unordered list of color-index tuples, any procedure that can
        generate this list of tuples is mathematically identical to 
        the process of drawing the sequences by choosing colored balls.\\

        Now imagine you had a bucket with n numbered tokens in it. Each
        token has number written on it ranging from 1 to n.\\ 
        
        One possible way to create an unordered list of color-index 
        tuples (and as a result, a way to create the original sequence
        of colored dashes) would be to first decide how many red tuples
        you wanted ahead of time, create those tuples by randomly selecting
        indices from the bucket, and then randomly choose between
        green and blue as you made the remaining tuples\\

        Again, assuming n = 5, you could start out by saying that you
        will have exactly 2 red tuples. To do this, you could randomly
        choose 2 tokens from the bucket without replacement.\\

        Whatever numbers you pulled out of the bucket, you would create
        red tuples using those numbers as your indices. For example,
        if the numbers you pulled out of the bucket were 1 and 4,
        then you would have the tuples (R, 1) and (R, 4). 
        This exactly defines the red dashes in the sequence presented
        earlier in this proof.\\

        However, there's no reason why the tokens pulled from the bucket
        had to be 1 and 4. Since you're choosing 2 tokens from a 
        set of 5 tokens without replacement, there are $\binom{5}{2}$
        possible ways to create 2 red tuples.\\

        After forming these red tuples, there are now 3 indices left.
        Each of these indices could be paired with either 
        the color green, or the color blue.\\

        You could choose to keep pulling numbers out of the bucket,
        assigning each index token that you pull out 
        to either green or blue based on the toss of a coin\\ 
        
        However, another equally valid approach would be to just 
        pour out the remaining tokens, line them up in ascending order,
        and then flip a coin as you look at each token one by one\\

        Heads means the index makes a tuple with green, tails means it
        makes a tuple with blue.\\
        
        If the remaining indices after making
        the red tuples were 2, 3, and 5, and if the three coin tosses
        had given the sequence H, H, T, then we would end up with the
        tuples\\

        (G, 2), (G, 3), (B, 5)\\

        Which represents the blue and green dashes in the example shown
        earlier in this proof.\\

        Because there are 2 possible outcomes for each of the 
        3 remaining tokens (Heads or Tails), the number of possible 
        ways to form the green and blue tuples is ${2}^{3}$.\\

        Since there are $\binom{5}{2}$ ways to form the red tuples, 
        and ${2}^{3}$ possible ways to form the green and blue tuples,
        there are $\binom{5}{2} * {2}^{3}$ possible ways to create
        5 index-color tuples where 2 have the color red\\

        This means that there are $\binom{5}{2} * {2}^{3}$ 
        possible ways to create a sequence of 5 colored dashes
        (from the colors red, green, and blue) 
        where two of those dashes are red\\

        However, if we go back to the tuple generation, there was no
        reason why we had to have exactly two red dashes. We could have
        had no red dashes, or five red dashes, or any number in between\\

        When we choose to have k red dashes, we end up with 
        $\binom{5}{2}$
        

    \end{proof}
    
    \item[b.]
    Time complexity: $\bigO (n)$
    \begin{proof}
    ($\Leftarrow$) Assume by Contradiction,
    
    ($\Rightarrow$)
    \end{proof}
    
\end{enumerate}
\newpage
\clearpage
\section{Question 2 Example Pseudocode}

\begin{algorithmic}[1]
	\Function{Gale-Shapley}{$E$, $S$}
	\State initialize all employers in $E$ and students in $S$ to unmatched
	\While {an unmatched employer with at least one student on its preference list remains}
	\State choose such an employer $e \in E$
	\State make offer to next student $s \in S$ on $e$'s preference list
	\If {$s$ is unmatched}
	\State Match $e$ with $s$ \Comment{$s$ accepts $e$'s offer}
	\ElsIf {$s$ prefers $e$ to their current employer $e'$}
	\State Unmatch $s$ and $e'$ \Comment{$s$ rejects $e'$}
	\State Match $e$ with $s$ \Comment{$s$ accepts $e$'s offer}
	\EndIf
	\State cross $s$ off $e$'s preference list
	\EndWhile
	\State report the set of matched pairs as the final matching
	\EndFunction
\end{algorithmic}


\newpage
\section{Question 3}
\begin{figure}[!htb] 
\caption{Example image \label{fig:eg}}
{This figure shows xxx\bigskip}

% \centering{\includegraphics[width=0.75\linewidth]{example-image}}
\end{figure}
\newpage
\clearpage

\section{Question 4 Induction}
\begin{enumerate}
    \item[a.]
    \begin{theorem}
        Some theorem here.
    \end{theorem}
    \begin{proof} Proof by induction
    
    \Base {When $n=1$, is true.}
    
    \IH {Suppose is true}
    
    \IS Consider when 
    \end{proof}
    
    \item[b.]
    Time complexity: $\bigO (n)$
    \begin{proof}
    ($\Leftarrow$) Assume by Contradiction,
    
    ($\Rightarrow$)
    \end{proof}
    
\end{enumerate}
\newpage
\clearpage

\section{Question 5 Probability}
\begin{enumerate}
    \item[a.]
    \begin{theorem}
        Some theorem here.
    \end{theorem}
    \begin{proof} Proof by induction
    
    \Base {When $n=1$, is true.}
    
    \IH {Suppose is true}
    
    \IS Consider when 
    \end{proof}
    
    \item[b.]
    Time complexity: $\bigO (n)$
    \begin{proof}
    ($\Leftarrow$) Assume by Contradiction,
    
    ($\Rightarrow$)
    \end{proof}
    
\end{enumerate}
\newpage
\clearpage

\section{Question 6 Graphs, Proof by Contradiction}
 
    \begin{proof}
        Assume by Contradiction,
        
        Assume \( d(u,w) + d(w,v) < d(u,v) \).
        
        This implies that there is a path from \( u \) to \( v \) via \( w \) whose total distance is less than the direct distance between \( u \) and \( v \).

        However, by the definition of \( d(u,v) \), it is the shortest distance between \( u \) and \( v \). Therefore, no other path, including one through \( w \), can have a smaller distance.

        This contradiction arises from our assumption, so the assumption must be false. Hence, we conclude that \( d(u,w) + d(w,v) \geq d(u,v) \).
    \end{proof}
        
    

\newpage
\clearpage

\section{Question 7 Trees, Proof by induction}
    \textbf{Definition:} A \emph{stable parent} is defined as a node with two leaves. Let:
    \begin{itemize}
        \item \( n \) be the number of nodes,
        \item \( l \) be the number of leaves,
        \item \( p \) be the number of stable parents.
    \end{itemize}

    \noindent \textbf{Proof.} Proof by induction.

    Assume the inductive hypothesis:
    \[
    l_n = p_n + 1 \quad \Rightarrow \quad l_{n+1} = p_{n+1} + 1
    \]

    \noindent We will now consider two cases:

    \textbf{Case 1:} Add a child to a leaf.
    \begin{itemize}
        \item Since the leaf gains a child, while a new leaf is added, we have \( l_{n+1} = l_n \).
        \item Since no node with 1 child gains another child, \( p_{n+1} = p_n \).
        \item Therefore, \( l_{n+1} = l_n = p_n + 1 = p_{n+1} + 1 \).
    \end{itemize}

    \textbf{Case 2:} Add a child to a node with 1 child already.
    \begin{itemize}
        \item Since no leaf stops being a leaf, you have simply added a leaf, so \( l_{n+1} = l_n + 1 \).
        \item Since the node with 1 child gains another child, a new stable parent is formed, so \( p_{n+1} = p_n + 1 \).
        \item Therefore, \( l_{n+1} = l_n + 1 = p_{n+1} + 1 = p_n + 1 + 1 \).
    \end{itemize}

    \noindent \textbf{Base case:} For \( n = 1 \), we have:
    \begin{itemize}
        \item 1 node implies 1 leaf and 0 stable parents.
        \item Thus, \( l_1 = 1 \) and \( p_1 = 0 \).
        \item Therefore, \( 1 = 0 + 1 \), which satisfies \( l_1 = p_1 + 1 \).
    \end{itemize}

    \noindent Q.E.D.
\newpage
\clearpage

\end{document}

